# Algorithms
> This repository contains solutions **[ in C++ ]** of a problem using different techniques like Dynamic Programming , Greedy Algorithms , Divide and Conquer , Backtracking etc.

## Here's some techniques to solve different kind of problems.

## Dynamic Programming
> Dynamic Programming is a method for solving a complex problem by breaking it down into a collection of simpler subproblems, solving each of those subproblems just once, and storing their solutions using a memory-based data structure (array, map,etc). Each of the subproblem solutions is indexed in some way, typically based on the values of its input parameters, so as to facilitate its lookup. So the next time the same subproblem occurs, instead of recomputing its solution, one simply looks up the previously computed solution, thereby saving computation time. This technique of storing solutions to subproblems instead of recomputing them is called memoization.

### Here's some problems and their solution(s):
- [0-1 Knapsack Problem](0-1%20Knapsack%20Problem)
- [Bell Numbers](/Bell%20Numbers)
- [Binomial Coefficient](/Binomial%20Coefficient)
- [Coin Change](/Coin%20Change)
- [Compute nCr mod p](/Compute%20nCr%20mod%20p)
- [Count all subsequences having product less than K](/Count%20all%20subsequences%20having%20product%20less%20than%20K)
- [Cutting a Rod](/Cutting%20a%20Rod)
- [Edit Distance](/Edit%20Distance)
- [Largest Sum Contiguous Subarray](/Largest%20Sum%20Contiguous%20Subarray)
- [Longest Common Subsequence](/Longest%20Common%20Subsequence)
- [Longest Increasing Subsequence](/Longest%20Increasing%20Subsequence)
- [Longest Repeated Subsequence](/Longest%20Repeated%20Subsequence)
- [Longest subsequence](/Longest%20subsequence)
- [Matrix Chain Multiplication](/Matrix%20Chain%20Multiplication)
- [Maximum Length Chain of Pairs](/Maximum%20Length%20Chain%20of%20Pairs)
- [Maximum Sum Increasing Subsequence](/Maximum%20Sum%20Increasing%20Subsequence)
- [Maximum games played by winner](/Maximum%20games%20played%20by%20winner)
- [Maximum length subsequence](/Maximum%20length%20subsequence)
- [Maximum path sum in a triangle](/Maximum%20path%20sum%20in%20a%20triangle)
- [Maximum product of an increasing subsequence](/Maximum%20product%20of%20an%20increasing%20subsequence)
- [Maximum size square sub-matrix with all 1s](/Maximum%20size%20square%20sub-matrix%20with%20all%201s)
- [Maximum Subsequence Sum](/Maximum%20subsequence%20sum)
- [Maximum sum of pairs with specific difference](/Maximum%20sum%20of%20pairs%20with%20specific%20difference)
- [Newman-Shanks-Williams Prime](/Newman-Shanks-Williams%20prime)
- [Nth Catalan Number](/Nth%20Catalan%20Number)
- [Permutation Coefficient](/Permutation%20Coefficient)
- [Size of The Subarray With Maximum Sum](/Size%20of%20The%20Subarray%20With%20Maximum%20Sum)
- [Subset Sum Problem](/Subset%20Sum%20Problem)
- [Ugly Numbers](/Ugly%20Numbers)


## Greedy Algorithms
> A greedy algorithm, as the name suggests, always makes the choice that seems to be the best at that moment. This means that it makes a locally-optimal choice in the hope that this choice will lead to a globally-optimal solution.
### Here's some problems and their solution(s):
- [Dijsktra](/Dijsktra)
- [Find Minimum number of Coins](/Minimum%20number%20of%20Coins)
- [Fractional Knapsack Problem](/Fractional%20Knapsack%20Problem)
- [Maximize the sum of arr[i]*i](/Maximize%20the%20sum%20of%20index%20by%20muliplying%20the%20element%20at%20the%20index)
- [Minimum Sum of Product of Two Arrays](/Minimum%20Sum%20of%20Product%20of%20Two%20Arrays)


## Divide and Conquer
> A typical Divide and Conquer algorithm solves a problem using following three steps.
> - Divide: Break the given problem into subproblems of same type.
> - Conquer: Recursively solve these subproblems
> - Combine: Appropriately combine the answers

### Here's some problems and their solution(s): 
- [Binary Search](/Binary%20Search)
- [Longest Common Prefix](/Longest%20Common%20Prefix)
- [Maximum Contiguous Subarray Sum](/Maximum%20Subarray%20Sum)

## Backtracking
> Backtracking is a general algorithm for finding all (or some) solutions to some computational problems, notably constraint satisfaction problems, that incrementally builds candidates to the solutions, and abandons a candidate ("backtracks") as soon as it determines that the candidate cannot possibly be completed to a valid solution.

### Here's some problems and their solution(s): 
- [Combinational Sum](/Combinational%20Sum)
- [N Queen Problem ](/N%20Queen%20Problem)
- [Sudoku](/Sudoku)
