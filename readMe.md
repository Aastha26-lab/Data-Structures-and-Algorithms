# Data Structures and Algorithms
  This repository contains data structure programs and solutions **in C++** of a problem using different techniques like Dynamic Programming , Greedy Algorithms , Divide and Conquer , Backtracking etc.

## Algorithm Design Techniques

<details>
<summary>Dynamic Programming</summary>
  
```
    Dynamic Programming is a method for solving a complex problem by breaking it down into a 
collection of simpler subproblems, solving each of those subproblems just once, and storing 
their solutions using a memory-based data structure (array, map,etc). Each of the subproblem 
solutions is indexed in some way, typically based on the values of its input parameters, so 
as to facilitate its lookup. So the next time the same subproblem occurs, instead of recomputing
its solution, one simply looks up the previously computed solution, thereby saving computation
time. This technique of storing solutions to subproblems instead of recomputing them is called
memoization.
```
  
### Here's some problems and their solution(s):
  
- [0-1 Knapsack Problem](0-1%20Knapsack%20Problem)
- [Bell Numbers](/Bell%20Numbers)
- [Binomial Coefficient](/Binomial%20Coefficient)
- [Coin Change](/Coin%20Change)
- [Compute nCr mod p](/Compute%20nCr%20mod%20p)
- [Count All Subsequences having Product Less than K](/Count%20all%20subsequences%20having%20product%20less%20than%20K)
- [Count Distinct Subsequences](/Count%20Distinct%20Subsequences)
- [Count Number of Increasing SubSequence](/Count%20Number%20of%20Increasing%20SubSequence)
- [Count Number of Subsets having Given XOR Value](/Count%20Number%20of%20Subsets%20having%20Given%20XOR%20Value)
- [Count Number of Ways to jump to Reach End](/Count%20Number%20of%20Ways%20to%20jump%20to%20Reach%20End)
- [Cutting A Rod](/Cutting%20a%20Rod)
- [Delannoy Number](/Delannoy%20Number)
- [Dice Throw Problem](/Dice%20Throw%20Problem)
- [Edit Distance](/Edit%20Distance)
- [Egg Dropping Puzzle](/Egg%20Dropping%20Puzzle)
- [Entringer Number](/Entringer%20Number)
- [Eulerian Number](/Eulerian%20Number)
- [Friends Pairing Problem](/Friends%20Pairing%20Problem)
- [Golomb Sequence](/Golomb%20Sequence)
- [Highway Billboard Problem](/Highway%20Billboard%20Problem)
- [Jacobsthal and Jacobsthal-Lucas numbers](/Jacobsthal%20and%20Jacobsthal-Lucas%20numbers)
- [Longest Arithmetic Progression](/Longest%20Arithmetic%20Progression)
- [Largest Sum Contiguous Subarray](/Largest%20Sum%20Contiguous%20Subarray)
- [Longest Bitonic Subsequence](/Longest%20Bitonic%20Subsequence)
- [Longest Common Increasing Subsequence](/Longest%20Common%20Increasing%20Subsequence)
- [Longest Common Subsequence](/Longest%20Common%20Subsequence)
- [Longest Common Substring](/Longest%20Common%20Substring)
- [Longest Geometric Progression](/Longest%20Geometric%20Progression)
- [Longest Increasing Subsequence](/Longest%20Increasing%20Subsequence)
- [Longest Palindromic Subsequence](/Longest%20Palindromic%20Subsequence)
- [Longest Repeated Subsequence](/Longest%20Repeated%20Subsequence)
- [Longest Subsequence](/Longest%20subsequence)
- [Matrix Chain Multiplication](/Matrix%20Chain%20Multiplication)
- [Maximum Length Chain of Pairs](/Maximum%20Length%20Chain%20of%20Pairs)
- [Maximum Sum Increasing Subsequence](/Maximum%20Sum%20Increasing%20Subsequence)
- [Maximum Games Played by Winner](/Maximum%20games%20played%20by%20winner)
- [Maximum Length Subsequence](/Maximum%20length%20subsequence)
- [Maximum Path Sum in A Triangle](/Maximum%20path%20sum%20in%20a%20triangle)
- [Maximum Product Cutting](/Maximum%20Product%20Cutting)
- [Maximum Product of An Increasing Subsequence](/Maximum%20product%20of%20an%20increasing%20subsequence)
- [Maximum Size Square Sub-Matrix with All 1s](/Maximum%20size%20square%20sub-matrix%20with%20all%201s)
- [Maximum Size Subset with Given Sum](/Maximum%20Size%20Subset%20with%20Given%20Sum)
- [Maximum Subsequence Sum](/Maximum%20subsequence%20sum)
- [Maximum Sum of Pairs with Specific Difference](/Maximum%20sum%20of%20pairs%20with%20specific%20difference)
- [Minimum Cost to Fill Given Weight in A Bag](/Minimum%20Cost%20to%20Fill%20Given%20Weight%20in%20A%20Bag)
- [Minimum Insertions to Form a Palindrome](/Minimum%20Insertions%20to%20Form%20a%20Palindrome)
- [Minimum Insertions to Sort An Array](/Minimum%20Insertions%20to%20Sort%20An%20Array)
- [Minimum Number of Jumps to Reach End](/Minimum%20Number%20of%20Jumps%20to%20Reach%20End)
- [Minimum Partition](/Minimum%20Partition)
- [Minimum Sum of Multiplications of N Numbers](/Minimum%20Sum%20of%20Multiplications%20of%20N%20Numbers)
- [Moser-de Bruijn Sequence](/Moser-de%20Bruijn%20Sequence)
- [Newman-Conway Sequence](/Newman-Conway%20Sequence)
- [Newman-Shanks-Williams Prime](/Newman-Shanks-Williams%20prime)
- [Nth Catalan Number](/Nth%20Catalan%20Number)
- [Number of N Digit(s) Stepping Numbers](/Number%20of%20N%20Digit(s)%20Stepping%20Numbers)
- [Optimal Strategy for a Game](/Optimal%20Strategy%20for%20a%20Game)
- [Painting Fence Algorithm](/Painting%20Fence%20Algorithm)
- [Palindrome Partitioning](/Palindrome%20Partitioning)
- [Perfect Sum Problem](/Perfect%20Sum%20Problem)
- [Permutation Coefficient](/Permutation%20Coefficient)
- [Size of The Subarray With Maximum Sum](/Size%20of%20The%20Subarray%20With%20Maximum%20Sum)
- [Smallest Sum Contiguous Subarray](/Smallest%20Sum%20Contiguous%20Subarray)
- [Stolen Values Problem](/Stolen%20Values%20Problem)
- [Subset Sum Problem](/Subset%20Sum%20Problem)
- [Sum of All Substrings of A String Representing A Number](/Sum%20of%20All%20Substrings%20of%20A%20String%20Representing%20A%20Number)
- [Sum of Average of All Subsets](/Sum%20of%20Average%20of%20All%20Subsets)
- [Super Ugly Number](/Super%20Ugly%20Number)
- [Temple Offerings](/Temple%20Offerings)
- [Tile Stacking Problem](Tile%20Stacking%20Problem)
- [Tiling Problem](/Tiling%20Problem)
- [Tiling with Dominoes](/Tiling%20with%20Dominoes)
- [Ugly Numbers](/Ugly%20Numbers)
- [Unbounded Knapsack](/Unbounded%20Knapsack)
- [Weighted Job Scheduling](/Weighted%20Job%20Scheduling)
- [Wildcard Pattern Matching](/Wildcard%20Pattern%20Matching)

<br>
</details>
<br>

<details>
<summary>Greedy Algorithms</summary>
  
```  /Super%20Ugly%20Number)
    A greedy algorithm, as the name suggests, always makes the choice that seems to be the 
best at that moment. This means that it makes a locally-optimal choice in the hope that 
this choice will lead to a globally-optimal solution.
```
  
### Here's some problems and their solution(s):

- [Dijsktra](/Dijsktra)
- [Find Minimum number of Coins](/Minimum%20number%20of%20Coins)
- [Fractional Knapsack Problem](/Fractional%20Knapsack%20Problem)
- [Maximize Array Sum After K Negations](/DATA%20STRUCTURES/Array/Maximize%20Array%20Sum%20After%20K%20Negations)
- [Maximize the sum of arr[i] x i](/Maximize%20the%20sum%20of%20index%20by%20muliplying%20the%20element%20at%20the%20index)
- [Maximum Product Subset of an Array](/Maximum%20Product%20Subset%20of%20an%20Array)
- [Minimum Product Subset of an Array](/Minimum%20Product%20Subset%20of%20an%20Array)
- [Minimum Sum of Absolute Difference of Pairs of Two Arrays](/Minimum%20Sum%20of%20Absolute%20Difference%20of%20Pairs%20of%20Two%20Arrays)
- [Minimum Sum of Product of Two Arrays](/Minimum%20Sum%20of%20Product%20of%20Two%20Arrays)
- [Split A Number into Maximum Composite Number](/Split%20A%20Number%20into%20Maximum%20Composite%20Number)

<br>
</details>
<br>

<details>
<summary>Divide and Conquer</summary>
  
```  
  A typical Divide and Conquer algorithm solves a problem using following three steps.
    - Divide: Break the given problem into subproblems of same type.
    - Conquer: Recursively solve these subproblems
    - Combine: Appropriately combine the answers
```
  
### Here's some problems and their solution(s):

- [Binary Search](/Binary%20Search)
- [Count Inversions in an Array](/Count%20Inversions)
- [Cubic Root of A Number](/Cubic%20Root%20of%20A%20Number)
- [Find A Fixed Point in A Given Array](/Find%20a%20Fixed%20Point%20in%20a%20Given%20Array)
- [Find A Peak Element](/Find%20A%20Peak%20Element)
- [Find Closest Number in Array](/Find%20Closest%20Number%20in%20Array)
- [Find the Element that appears once in a Sorted Array](/Find%20the%20Element%20that%20appears%20once%20in%20a%20Sorted%20Array)
- [Floor in a Sorted Array](/Floor%20in%20a%20Sorted%20Array)
- [K-th Element of Two Sorted Arrays](/K-th%20Element%20of%20Two%20Sorted%20Arrays)
- [Longest Common Prefix](/Longest%20Common%20Prefix)
- [Majority Element](/Majority%20Element)
- [Maximum Contiguous Subarray Sum](/Maximum%20Subarray%20Sum)
- [Median of Two Sorted Arrays of Same Size](/Median%20of%20Two%20Sorted%20Arrays%20of%20Same%20Size)
- [Number of Zeros](/Number%20of%20Zeros)
- [Rotation Count in Rotated Sorted Array](/Rotation%20Count%20in%20Rotated%20Sorted%20Array)

<br>
</details>
<br>

<details>
<summary>Backtracking</summary>
  
```  
    Backtracking is a general algorithm for finding all (or some) solutions to some 
computational problems, notably constraint satisfaction problems, that incrementally
builds candidates to the solutions, and abandons a candidate ("backtracks") as soon 
as it determines that the candidate cannot possibly be completed to a valid solution.
```

### Here's some problems and their solution(s):
  
- [Boggle](/Boggle)
- [Combinational Sum](/Combinational%20Sum)
- [Graph Coloring Problem](/Graph%20Coloring%20Problem)
- [Hamiltonian Cycle](/Hamiltonian%20Cycle)
- [N Queen Problem ](/N%20Queen%20Problem)
- [Power Set in Lexicographical Order](/Power%20Set%20in%20Lexicographic%20order)
- [Remove Invalid Parentheses](/Remove%20Invalid%20Parentheses)
- [Sudoku](/Sudoku)
- [The Knight’s Tour Problem](/The%20Knight’s%20Tour%20Problem)

<br>
</details>
<br>

<details>
<summary>Miscellaneous</summary>
  
```  
    Except above algorithm design techniques , here's some important
algorithms.
```

### Here's some problems and their solution(s):
  
- [Dutch National Flag Algorithm](/DATA%20STRUCTURES/Array/Sort%20An%20Array%20of%200s%20-%201s%20and%202s/code_2.cpp)
- [MO’s Algorithm](/DATA%20STRUCTURES/Array/Query%20Square%20Root%20Decomposition/code_2.cpp)
- [Reservoir Sampling](/Reservoir%20Sampling)  
- [String Matching Algorithms](/String%20Matching%20Algorithms)

<br>
</details>
<br>


## Data Structures

<details>
<summary>Array/Vector/Matrix</summary>
  
```  
    An array is a collection of items stored at contiguous memory locations. The idea is to 
store multiple items of the same type together. This makes it easier to calculate the position
of each element by simply adding an offset to a base value, i.e., the memory location of the 
first element of the array (generally denoted by the name of the array).
    Vector is Dynamic Array.
    Matrix is 2D Array.
```
### Here's some problems and their solution(s):
- [Arrange Given Numbers to Form the Biggest Number](/DATA%20STRUCTURES/Array/Arrange%20Given%20Numbers%20to%20Form%20the%20Biggest%20Number)
- [Array Range Queries for Searching An Element](/DATA%20STRUCTURES/Array/Array%20Range%20Queries%20for%20Searching%20An%20Element)
- [Array Rearrangement by Shifting Zero to end](/DATA%20STRUCTURES/Array/Array%20Rearrangement%20by%20Shifting%20Zero%20to%20end)
- [Chocolate Distribution Problem](/DATA%20STRUCTURES/Array/Chocolate%20Distribution%20Problem)
- [Convert Array into Zig-Zag Fashion](/DATA%20STRUCTURES/Array/Convert%20Array%20into%20Zig-Zag%20Fashion)
- [Count Number of Primes in Given Range](/DATA%20STRUCTURES/Array/Count%20Number%20of%20Primes%20in%20Given%20Range)
- [Count Smaller Elements On Right Side](/DATA%20STRUCTURES/Array/Count%20Smaller%20Elements%20On%20Right%20Side)
- [Count Strictly Increasing Subarrays](/DATA%20STRUCTURES/Array/Count%20Strictly%20Increasing%20Subarrays)
- [Elements that Occurred Only Once in An Array](/DATA%20STRUCTURES/Array/Elements%20that%20Occurred%20Only%20Once)
- [Find The Largest Three Elements in An Array](/DATA%20STRUCTURES/Array/Find%20The%20Largest%20Three%20Elements%20in%20An%20Array)
- [Find the Missing Number](/DATA%20STRUCTURES/Array/Find%20the%20Missing%20Number)
- [Find The Smallest Missing Number](/DATA%20STRUCTURES/Array/Find%20The%20Smallest%20Missing%20Number)
- [Kth Smallest/Largest Element](/DATA%20STRUCTURES/Array/Kth%20Smallest%20Element)
- [Largest SubArray with Equal Number of 1s and 0s](/DATA%20STRUCTURES/Array/Largest%20SubArray%20with%20Equal%20Number%20of%201s%20and%200s)
- [Maximize Array Sum After K Negations](/DATA%20STRUCTURES/Array/Maximize%20Array%20Sum%20After%20K%20Negations)
- [Maximum of All SubArrays of Size k](/DATA%20STRUCTURES/Array/Maximum%20of%20All%20SubArrays%20of%20Size%20k)
- [Maximum Product Subarray](/DATA%20STRUCTURES/Array/Maximum%20Product%20Subarray)
- [Maximum Sum Such That No Two Elements Are Adjacent](/DATA%20STRUCTURES/Array/Maximum%20Sum%20Such%20That%20No%20Two%20Elements%20Are%20Adjacent)
- [Mean and Median for Unsorted Array](/DATA%20STRUCTURES/Array/Mean%20and%20Median%20for%20Unsorted%20Array)
- [Mean of Range in An Array](/DATA%20STRUCTURES/Array/Mean%20of%20Range%20in%20An%20Array)
- [Merge Overlapping Intervals](/DATA%20STRUCTURES/Array/Merge%20Overlapping%20Intervals)
- [Min-Max Range Queries in Array](/DATA%20STRUCTURES/Array/Min-Max%20Range%20Queries%20in%20Array)
- [Move All Zeros to end of Array](/DATA%20STRUCTURES/Array/Move%20All%20Zeros%20to%20end%20of%20Array)
- [Next Greater Element](/DATA%20STRUCTURES/Array/Next%20Greater%20Element)
- [Positive Elements at Even and Negative at Odd Position in An Array](/DATA%20STRUCTURES/Array/Positive%20Elements%20at%20Even%20and%20Negative%20at%20Odd%20Position)
- [Product of Ranges in An Array](/DATA%20STRUCTURES/Array/Product%20of%20Ranges%20in%20An%20Array)
- [Query Square Root Decomposition](/DATA%20STRUCTURES/Array/Query%20Square%20Root%20Decomposition)
- [Rearrange An Array in Order - Smallest - S , Largest - L , 2nd S , 2nd L](/DATA%20STRUCTURES/Array/Rearrange%20An%20Array%20in%20A%20Specific%20Order)
- [Replace Array Element by Multiplication of Previous and Next](/DATA%20STRUCTURES/Array/Replace%20Every%20Array%20Element)
- [Segregate 0s and 1s in an Array](/DATA%20STRUCTURES/Array/Segregate%200s%20and%201s)
- [Segregate Even and Odd Numbers](/DATA%20STRUCTURES/Array/Segregate%20Even%20and%20Odd%20Numbers)
- [Shortest Un-ordered SubArray](/DATA%20STRUCTURES/Array/Shortest%20Un-ordered%20SubArray)
- [Sort An Array of 0s , 1s and 2s](/DATA%20STRUCTURES/Array/Sort%20An%20Array%20of%200s%20-%201s%20and%202s)
<br>
</details>
<br>

<details>
<summary>Linked List</summary>
  
```  
    A linked list is a linear data structure, in which the elements are not stored at 
contiguous memory locations.
```
### Here's some problems and their solution(s):
- [Insertion & Deletion in Singly Linked List](/DATA%20STRUCTURES/Linked%20List/code_1.cpp)
- [Reverse Singly Linked List in Pairs](/DATA%20STRUCTURES/Linked%20List/code_2.cpp)
<br>
</details>
<br>

<details>
<summary>Binary Tree</summary>
  
```  
    A tree whose elements have at most 2 children is called a binary tree. Since each element 
in a binary tree can have only 2 children, we typically name them the left and right child.
```
### Here's some problems and their solution(s):
- [Insertion and Recursive Traversal](/DATA%20STRUCTURES/Binary%20Tree/code_1.cpp)
<br>
</details>
<br>

<details>
<summary>Binary Search Tree</summary>
  
```  
    Binary Search Tree is a node-based binary tree data structure which has the following properties:
    - The left subtree of a node contains only nodes with keys lesser than the node’s key.
    - The right subtree of a node contains only nodes with keys greater than the node’s key.
    - The left and right subtree each must also be a binary search tree.
```
### Here's some problems and their solution(s):
- [Insertion , Deletion , Search and Recursive Traversal](/DATA%20STRUCTURES/Binary%20Search%20Tree/code_1.cpp)

<br>
</details>
<br>

<details>
<summary>Heap</summary>
  
```  
    A Heap is a special Tree-based data structure in which the tree is a complete binary tree. 
Generally, Heaps can be of two types:
     - Max-Heap: In a Max-Heap the key present at the root node must be greatest among the keys
            present at all of it’s children. The same property must be recursively true for all 
            sub-trees in that Binary Tree.
     - Min-Heap: In a Min-Heap the key present at the root node must be minimum among the keys 
            present at all of it’s children. The same property must be recursively true for all 
            sub-trees in that Binary Tree.
```

<br>
</details>
<br>

<details>
<summary>Hash Map</summary>
  
```  
    Hashing is an important Data Structure which is designed to use a special function 
called the Hash function which is used to map a given value with a particular key for 
faster access of elements. The efficiency of mapping depends of the efficiency of the 
hash function used.
```

<br>
</details>
<br>


<details>
<summary>Graph</summary>
  
```  
    A Graph is a non-linear data structure consisting of nodes and edges. The nodes are
sometimes also referred to as vertices and the edges are lines or arcs that connect any 
two nodes in the graph.
```
### Here's some problems and their solution(s):
- [Breadth First Search](/DATA%20STRUCTURES/Graph/Breadth%20First%20Search)
- [Depth First Search](/DATA%20STRUCTURES/Graph/Depth%20First%20Search)
- [Number of Nodes at Given Level](/DATA%20STRUCTURES/Graph/Number%20of%20Nodes%20at%20Given%20Level)
<br>
</details>
<br>

<details>
<summary>Trie</summary>
  
```  
    In computer science, a trie, also called digital tree, radix tree or prefix tree is a 
kind of search tree—an ordered tree data structure used to store a dynamic set or associative 
array where the keys are usually strings. Unlike a binary search tree, no node in the tree 
stores the key associated with that node; instead, its position in the tree defines the key 
with which it is associated. All the descendants of a node have a common prefix of the string
associated with that node, and the root is associated with the empty string. Keys tend to be 
associated with leaves, though some inner nodes may correspond to keys of interest. Hence, 
keys are not necessarily associated with every node. For the space-optimized presentation of 
prefix tree, see compact prefix tree.
```

<br>
</details>
<br>
